#include<p18f4550.h> //Include controller specific .h files#pragma config FOSC = HS //Oscillator Selection#pragma config WDT = OFF //Disable Watchdog Timer#pragma config LVP = OFF //Disable low Voltage Programming#pragma config PBADEN = OFF //Disable PORTB Analog Inputs//Declarations for LCD Connection#define LCD_DATA PORTD //LCD Data port#define en PORTEbits.RE2 //Enable Signal#define rw PORTEbits.RE1 //Read/Write Signal#define rs PORTEbits.RE0 //Register Select Signal//Function PrototypesVoid ADC_init(void); //Function to initialize the ADCUnsigned int Get_ADC_Result(void); //Function to get ADC resultVoid Start_conversion(void); //Function to start the conversionVoid msdelay(unsigned int time); //Function to generate delayVoid init_LCD(void); //Function to initialize the LCDVoid LCD_command(unsigned char cmd);Void LCD_data(unsigned char data);Void LCD_write_string(static char *str);//Start of the ProgramVoid main(void){Char msg1[] = “Welcome E&TC”;Char msg2[] = “ADC O/P”;Unsigned char I, Thousands, Hundreds, Tens, Ones;Unsigned int adc_val;ADCON1 = 0x0F; //Configuring the port pins as Digital I/OTRISD = 0x00; //Configuring PORTD as OutputTRISE = 0x00; //Configuring PORTE as OutputADC_init(); //initialize ADC PeripheralsInit_LCD(); //initialize LCD ModuleLCD_write_string(msg1); //Display the welcome messageLCD_command(0xC0); //Go to Second Line, 0th place of LCDLCD_write_string(msg2); //Display message ADC O/PWhile(1){ Start_conversion(); //Trigger Conversion Adc_val = Get_ADC_Result(); //Get the ADC O/P  LCD_command(0xC8); //Go to 9th place on second lineof LCD  I = adc_val/1000; //Get the thousands place digit Thousands = I + 0x30; //Convert it to ASCII Value LCD_data(Thousands); //Display the Thousands place value  I = (adc_val%1000)/100; //Get the Hundreds place digit Thousands = I + 0x30; //Convert it to ASCII Value LCD_data(Thousands); //Display the Hundreds place value  I = ((adc_val%1000)%100)/10; //Get the Tens place digit Thousands = I + 0x30; //Convert it to ASCII Value LCD_data(Thousands); //Display the Tens place value  I = adc_val%10; //Get the Ones place value Ones = I + 0x30; //Convert it to ASCII value LCD_data(Ones); //Display the Ones value  Msdelay(300);}}//Function definitionsVoid ADC_init(){ADCON0 = 0b00000100; //A/D Module is OFF and Channel 1 is selectedADCON1 = 0b00001110; //Reference as VDD & VSS, AN0 set as analog pinsADCON2 = 0b10001110; //Result is right justifiedADCON0bits.ADON = 1; //Turn on the ADC module}Void Start_conversion(){ADCON0bits.GO = 1;}//if you do not wish to use ADC Conversion interrupt you can use this//to do the conversion manually. It assumes conversion format is right adjustedUnsigned int Get_ADC_Result(){Unsigned int ADC_Result = 0;While(ADCON0bits.GO);ADC_Result = ADRESL;ADC_Result |= ((unsigned int)ADRESH) << 8;Return ADC_Result;}Void msdelay(unsigned int time){Unsigned int I,j;For(i=0;i<time;i++){ For(j=0;j<275;j++);}}Void init_LCD(void){LCD_command(0x38); //Initialization of 16X2 LCD in 8-bit modeMsdelay(15);LCD_command(0x01); //Clear LCDMsdelay(15);LCD_command(0x0C); //Cursor OFFMsdelay(15);LCD_command(0x80); //Go to first line and 0th positionMsdelay(15);}Void LCD_command(unsigned char cmd) //Function to pass command to the LCD{LCD_DATA = cmd; //Send data on the LCD data busRs = 0; //RS = 0 Since we are giving command to LCDRw = 0; //RW = 0 Since we are writing the data on LCDEn = 1; //Generate High to Low pulse on ENMsdelay(15);En = 0; }Void LCD_data(unsigned char data){LCD_DATA = data; //Send data on the LCD data busRs = 1; //RS = 1 Since we are giving data to LCDRw = 0; //RW = 0 Since we are writing the data on LCDEn = 1; //Generate High to Low pulse on ENMsdelay(15);En = 0; }//Function to write string to LCDVoid LCD_write_string(static char *str){Int i=0;While(str[i]!=0){ LCD_data(str[i]); //Send the data byte by byte Msdelay(15); I++;}}